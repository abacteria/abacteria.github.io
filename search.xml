<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>三叉树求最大路径和</title>
      <link href="/2022/10/12/%E4%B8%89%E5%8F%89%E6%A0%91%E6%B1%82%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2022/10/12/%E4%B8%89%E5%8F%89%E6%A0%91%E6%B1%82%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的最大路径和"><a class="markdownIt-Anchor" href="#二叉树的最大路径和"></a> 二叉树的最大路径和</h1><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">LeetCode 124.二叉树的最大路径和</a></p><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><img src="/2022/10/12/%E4%B8%89%E5%8F%89%E6%A0%91%E6%B1%82%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/exx2.jpg" class="" title="img"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftGain</span> <span class="operator">=</span> Math.max(maxGain(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightGain</span> <span class="operator">=</span> Math.max(maxGain(node.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">priceNewpath</span> <span class="operator">=</span> node.val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = Math.max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node.val + Math.max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="建树"><a class="markdownIt-Anchor" href="#建树"></a> 建树</h1><p>在笔试题中，需要自己根据数组建树。数组的形式不同，有两种建树方式。</p><ol><li><p><strong>递归法</strong>：三叉树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] tree, <span class="type">int</span> idx)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx] == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(tree[idx]);</span><br><span class="line">    <span class="keyword">if</span>(idx * <span class="number">3</span> + <span class="number">1</span> &lt; tree.length)&#123;</span><br><span class="line">        root.left = buildTree(tree, idx * <span class="number">3</span> + <span class="number">1</span>);<span class="comment">//二叉树将3改为2，并少一个if语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(idx * <span class="number">3</span> + <span class="number">2</span> &lt; tree.length)&#123;</span><br><span class="line">        root.middle = buildTree(tree, idx * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(idx * <span class="number">3</span> + <span class="number">3</span> &lt; tree.length)&#123;</span><br><span class="line">        root.right = buildTree(tree, idx * <span class="number">3</span> + <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法需要数组非常的完整，对于<code>null</code>节点的左右节点，仍然需要在数组中用<code>null</code>表示，否则数组长度不够会导致建的树不完整。</p></li><li><p><strong>层序遍历</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//利用队列先进先出的特性</span></span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; idx &lt; nums.length)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">            queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(idx &lt; nums.length &amp;&amp; nums[idx] != -<span class="number">1</span>)&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">Node</span>(nums[idx]);</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.left = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">if</span>(idx &lt; nums.length &amp;&amp; nums[idx] != -<span class="number">1</span>)&#123;<span class="comment">//二叉树少一个if语句</span></span><br><span class="line">                node.middle = <span class="keyword">new</span> <span class="title class_">Node</span>(nums[idx]);</span><br><span class="line">                queue.offer(node.middle);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.middle = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">if</span>(idx &lt; nums.length &amp;&amp; nums[idx] != -<span class="number">1</span>)&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">Node</span>(nums[idx]);</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.right = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​该方法的数组不需要将<code>null</code>节点的子节点表示出来。</p><h1 id="三叉树的最大路径和"><a class="markdownIt-Anchor" href="#三叉树的最大路径和"></a> 三叉树的最大路径和</h1><p>对于笔试题的三叉树，只需将上两步融合。</p><img src="/2022/10/12/%E4%B8%89%E5%8F%89%E6%A0%91%E6%B1%82%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/image-20221013121058751.png" class="" title="image-20221013121058751"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">19</span><br><span class="line">20 12 30 15 -1 -1 -1 -1 -1 -1 15 5 25 -1 -1 -1 16 -1 22</span><br><span class="line">其中，-1表示空节点</span><br><span class="line">输出：</span><br><span class="line">92</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node middle;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">       <span class="type">int</span>[] tree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">           tree[i] = sc.nextInt();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(tree);</span><br><span class="line">       maxGain(root);</span><br><span class="line">       System.out.println(maxSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftGain</span> <span class="operator">=</span> Math.max(maxGain(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">middleGain</span> <span class="operator">=</span> Math.max(maxGain(node.middle), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightGain</span> <span class="operator">=</span> Math.max(maxGain(node.right), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> node.val + Math.max(leftGain + middleGain, Math.max(middleGain + rightGain, leftGain + rightGain));</span><br><span class="line">        maxSum = Math.max(maxSum, price);</span><br><span class="line">        <span class="keyword">return</span> node.val + Math.max(Math.max(leftGain, middleGain), rightGain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; idx &lt; nums.length)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">                queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(idx &lt; nums.length &amp;&amp; nums[idx] != -<span class="number">1</span>)&#123;</span><br><span class="line">                    node.left = <span class="keyword">new</span> <span class="title class_">Node</span>(nums[idx]);</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.left = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">                <span class="keyword">if</span>(idx &lt; nums.length &amp;&amp; nums[idx] != -<span class="number">1</span>)&#123;</span><br><span class="line">                    node.middle = <span class="keyword">new</span> <span class="title class_">Node</span>(nums[idx]);</span><br><span class="line">                    queue.offer(node.middle);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.middle = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">                <span class="keyword">if</span>(idx &lt; nums.length &amp;&amp; nums[idx] != -<span class="number">1</span>)&#123;</span><br><span class="line">                    node.right = <span class="keyword">new</span> <span class="title class_">Node</span>(nums[idx]);</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/er-cha-shu-zhong-de-zui-da-lu-jing-he-by-leetcode-/">LeetCode官方题解</a></p><p><a href="https://jiankychen.github.io/">jiankychen教你学算法 - 学算法，看我就够了</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka学习之路</title>
      <link href="/2022/09/27/Kafka%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/2022/09/27/Kafka%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h1><img src="/2022/09/27/Kafka%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZSP5ZmX,size_20,color_FFFFFF,t_70,g_se,x_16.jpeg" class="" title="在这里插入图片描述"><ul><li>Producer：消息⽣产者，向 Kafka Broker 发消息的客户端。</li><li>Consumer：消息消费者，从 Kafka Broker 取消息的客户端。Kafka支持持久化，生产者退出后，未消费的消息仍可被消费。</li><li>Consumer Group：消费者组（CG），消费者组内每个消费者负责消费不同分区的数据，提⾼消费能⼒。⼀个分区只能由组内⼀个消费者消费，消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的⼀个订阅者。</li><li>Broker：⼀台 Kafka 机器就是⼀个 Broker。⼀个集群(kafka cluster)由多个 Broker 组成。⼀个 Broker 可以容纳多个 Topic。</li><li>Controller：由zookeeper选举其中一个Broker产生。它的主要作用是在 Apache ZooKeeper 的帮助下管理和协调整个 Kafka 集群。</li><li>Topic：可以理解为⼀个队列，Topic 将消息分类，⽣产者和消费者⾯向的是同⼀个 Topic。</li><li>Partition：为了实现扩展性，提⾼并发能⼒，⼀个⾮常⼤的 Topic 可以分布到多个 Broker上，⼀个 Topic 可以分为多个 Partition，同⼀个topic在不同的分区的数据是不重复的，每个 Partition 是⼀个有序的队列，其表现形式就是⼀个⼀个的⽂件夹。不同Partition可以部署在同一台机器上，但不建议这么做。</li><li>Replication：每⼀个分区都有多个副本，副本的作⽤是做备胎。当主分区（Leader）故障的时候会选择⼀个备胎（Follower）上位，成为Leader。在kafka中默认副本的最⼤数量是10个，且副本的数量不能⼤于Broker的数量，follower和leader绝对是在不同的机器，同⼀机器对同⼀个分区也只可能存放⼀个副本（包括⾃⼰）。</li><li>Message：每⼀条发送的消息主体。</li><li>Leader：每个分区多个副本的“主”副本，⽣产者发送数据的对象，以及消费者消费数据的对象，都是 Leader。</li><li>Follower：每个分区多个副本的“从”副本，使用发布订阅模式主动拉取Leader的数据（与redis不同），实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发⽣故障时，某个 Follower 还会成为新的 Leader。</li><li>Offset：消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可以从消费位置继续消费。</li><li>ZooKeeper：Kafka 集群能够正常⼯作，需要依赖于 ZooKeeper，ZooKeeper 帮助 Kafka存储和管理集群信息。</li><li>High Level API 和Low Level API ：高水平API，kafka本身定义的行为，屏蔽细节管理，使用方便；低水平API细节需要自己处理，较为灵活但是复杂。</li></ul><h1 id="工作流程"><a class="markdownIt-Anchor" href="#工作流程"></a> 工作流程</h1><img src="/2022/09/27/Kafka%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZSP5ZmX,size_20,color_FFFFFF,t_70,g_se,x_16-20221019114339158.jpeg" class="" title="在这里插入图片描述"><p>Kafka集群将 Record 流存储在称为 Topic 的类中，每个记录由⼀个键、⼀个值和⼀个时间戳组成。<br />Kafka 中消息是以 Topic 进⾏分类的，⽣产者⽣产消息，消费者消费消息，⾯向的都是同⼀个Topic。Topic 是逻辑上的概念，⽽ Partition 是物理上的概念，每个 Partition 对应于⼀个 log ⽂件，该log ⽂件中存储的就是 Producer ⽣产的数据。Producer ⽣产的数据会不断追加到该 log ⽂件末端，且每条数据都有⾃⼰的 Offset。消费者组中的每个消费者，都会实时记录⾃⼰消费到了哪个 Offset，以便出错恢复时，从上次的位置继续消费。</p><h1 id="存储机制"><a class="markdownIt-Anchor" href="#存储机制"></a> 存储机制</h1><img src="/2022/09/27/Kafka%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZSP5ZmX,size_20,color_FFFFFF,t_70,g_se,x_16-20221019114647932.jpeg" class="" title="在这里插入图片描述"><p>由于⽣产者⽣产的消息会不断追加到 log ⽂件末尾，为防⽌ log ⽂件过⼤导致数据定位效率低下，Kafka 采取了分⽚和索引机制。它将每个 Partition 分为多个 Segment，每个 Segment 对应两个⽂件：<code>.index</code>索引⽂件和 <code>.log</code> 数据⽂件。这种索引思想值得我们学习应用到平时的开发中。</p><h1 id="怎么避免重复消费"><a class="markdownIt-Anchor" href="#怎么避免重复消费"></a> 怎么避免重复消费</h1><p><strong>出现重复消费的情况：</strong></p><ul><li><code>Broker</code>存储的消息都有<code>Offset</code>标记，消费者通过<code>Offset</code>标记维护当前已经消费的数据，每消费一批数据，就更新一次。消费端默认<code>5</code>秒后向<code>Broker</code>获取消息时，自动提交<code>Offset</code>。当消费者消费时，应用程序宕机，可能导致<code>Offset</code>没有提交，产生重复消费。</li><li><code>Partition Balance</code>机制，把多个<code>Partition</code>均衡的分给多个消费者。如果<code>Consumer</code>在默认的<code>5</code>分钟内没有处理完这一批消息，就会触发Kafka的<code>Rebalance</code>机制，导致<code>Offset</code>提交失败。<code>Rebalance</code>后，<code>Consumer</code>端继续从未提交的<code>Offset</code>位置进行消费。</li></ul><p><strong>解决方法：</strong></p><ul><li>提高消费端处理性能，避免处罚<code>Balance</code>。<ol><li>采用<code>异步</code>的方式处理消息，缩短单个消息消费的时长。</li><li>调整消息处理的超时时间。</li><li>减少一次性从<code>Broker</code>上拉取的数据条数。</li></ol></li><li>针对消息生成<code>md5</code>然后保存到<code>mysql</code>或者<code>redis</code>里，在处理消息之前先去<code>mysql</code>或者<code>redis</code>藜麦牛奶判断是否已经消费过。</li></ul><h1 id="如何保证信息不丢失"><a class="markdownIt-Anchor" href="#如何保证信息不丢失"></a> 如何保证信息不丢失</h1><ol><li><p><code>Producer</code>端确保消息能够到达<code>Broker</code>，并且实现消息的存储。这过程如果发生网络问题，有可能消息丢失。</p><p><strong>解决方法：</strong></p><ul><li>把<code>异步发送</code>改为<code>同步发送</code>，这样<code>Producer</code>就能实时知道消息发送的结果。</li><li>添加异步回调函数来监听消息发送的结果，如果发送失败，可以在回调中重试。</li><li>重试参数<code>retries</code>，<code>Producer</code>自动重试。</li></ul></li><li><p><code>Broker</code>端将消息持久化到磁盘。Kafka为提升性能，采用<code>异步批量</code>的实现机制，按照一定的消息量和时间间隔去刷盘。刷盘的动作由操作系统调度，若刷盘前系统崩溃，则数据丢失。</p><p><strong>解决方法：</strong></p><ul><li><code>Partition副本机制</code>以及<code>acks机制</code>：<ul><li><code>producer</code>端设置<code>request.required.acks = 0</code>；只要请求已发送出去，就算是发送完了，不关心有没有写成功。性能很好，如果是对一些日志进行分析，可以承受丢数据的情况，用这个参数，性能会很好。</li><li><code>request.required.acks = 1</code>；发送一条消息，当leader partition写入成功以后，才算写入成功。不过这种方式也有丢数据的可能。</li><li><code>request.required.acks = -1</code>；需要ISR列表里面，所有副本都写完以后，这条消息才算写入成功。</li></ul></li></ul></li></ol><h1 id="kafka如何保证消息消费的顺序性"><a class="markdownIt-Anchor" href="#kafka如何保证消息消费的顺序性"></a> Kafka如何保证消息消费的顺序性</h1><p><code>Producer</code>发送消息的时候，根据消息的<code>key</code>进行取模，来决定把当前消息存储到哪一个<code>Partition</code>中。因<code>Consumer</code>是完全独立的网络节点，就可能会出现读取不是按照发送顺序来实现的。</p><img src="/2022/09/27/Kafka%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/IMG_0857.PNG" class="" title="IMG_0857"><p><strong>解决方法：</strong></p><ul><li>自定义消息分区的路由算法，把指定的<code>key</code>都发送到同一个<code>Partition</code>中，指定一个<code>Consumer</code>去消费。</li><li><code>Consumer</code>端采用<strong>阻塞队列</strong>，将获取的消息先保存到阻塞队列，再用<strong>异步线程</strong>从阻塞队列中获取消息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>波形排列的字符串</title>
      <link href="/2022/09/13/%E6%B3%A2%E5%BD%A2%E6%8E%92%E5%88%97%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/09/13/%E6%B3%A2%E5%BD%A2%E6%8E%92%E5%88%97%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>输入一个宇符串<code>s</code>和正整数<code>numRows</code>，对宇符串<code>s</code>按规则进行波形排列，然后按规则输出新的宇符串。<br />波形排列规则如下：<br />1.波峰和波谷的宽度固定为<code>3</code>;<br />2.波形高度为<code>rowNums</code>;<br />3.从左到右，从下到上排列<code>rowNums</code>个宇符，从在到右排列3个宇符，从下到上<code>rowNums</code>个字符，以此类推。<br />宇符串输出规则：<br />从上到下逐行读取，每行从左到右读取。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如，输入“ABCDEFGHIJKLMNOPQ”3,</span><br><span class="line">则排列形状如下：</span><br><span class="line">    E F G   M N O</span><br><span class="line">    D   H   L   P</span><br><span class="line">A B C   I J K   Q</span><br><span class="line">输出</span><br><span class="line">&quot;EFGMNODHLPABCIJKQ&quot;</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String str, <span class="type">int</span> numRows)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">3</span>)<span class="keyword">return</span> str;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        String[] waves = <span class="keyword">new</span> <span class="title class_">String</span>[numRows];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;<span class="comment">//思路：while循环内模拟方向</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">2</span> &amp;&amp; i &lt; len; i++, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(waves[numRows - <span class="number">1</span>] == <span class="literal">null</span>)&#123;<span class="comment">//防止拼接成nullA</span></span><br><span class="line">                    waves[numRows - <span class="number">1</span>] = Character.toString(str.charAt(i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    waves[numRows - <span class="number">1</span>] += str.charAt(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> numRows - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; i &lt; len; i++, j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(waves[j] == <span class="literal">null</span>)&#123;</span><br><span class="line">                    waves[j] = Character.toString(str.charAt(i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    waves[j] += str.charAt(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">2</span> &amp;&amp; i &lt; len; i++, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(waves[<span class="number">0</span>] == <span class="literal">null</span>)&#123;</span><br><span class="line">                    waves[<span class="number">0</span>] = Character.toString(str.charAt(i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    waves[<span class="number">0</span>] += str.charAt(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; numRows - <span class="number">1</span> &amp;&amp; i &lt; len; i++, j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(waves[numRows - <span class="number">1</span>] == <span class="literal">null</span>)&#123;</span><br><span class="line">                    waves[j] = Character.toString(str.charAt(i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    waves[j] += str.charAt(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="number">0</span>; ii &lt; numRows; ii++)&#123;</span><br><span class="line">            sb.append(waves[ii]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://jiankychen.github.io/">jiankychen教你学算法 - 学算法，看我就够了</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 59.螺旋矩阵II</title>
      <link href="/2022/09/12/LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
      <url>/2022/09/12/LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
      
        <content type="html"><![CDATA[<h1 id="螺旋矩阵ii"><a class="markdownIt-Anchor" href="#螺旋矩阵ii"></a> 螺旋矩阵II</h1><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p><img src="/2022/09/12/LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/spiraln.jpg" class="" title="img"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><h1 id="方法模拟"><a class="markdownIt-Anchor" href="#方法模拟"></a> 方法：模拟</h1><p><strong>算法思路：</strong></p><ol><li>定义当前上下左右边界<code>t,b,l,r</code>，初始值<code>num = 1</code>，迭代终止值<code>tar = n * n</code>；</li><li>按顺序填入空矩阵，填完一条边时，边界要收缩。</li><li>以<code>num &lt;= tar</code>作为循环条件，而不是<code>l &lt; r || t &lt; b</code>，以防<code>n</code>为奇数时，矩阵中心数字无法填充。</li></ol><img src="/2022/09/12/LeetCode-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/ccff416fa39887c938d36fec8e490e1861813d3bba7836eda941426f13420759-Picture1.png" class="" title="Picture1.png"><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, t = <span class="number">0</span>, r = n - <span class="number">1</span>, b = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tar</span> <span class="operator">=</span> n * n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt;= tar)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++)&#123;</span><br><span class="line">                ans[t][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            t++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++)&#123;</span><br><span class="line">                ans[i][r] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;= l; i--)&#123;</span><br><span class="line">                ans[b][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            b--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; i &gt;= t; i--)&#123;</span><br><span class="line">                ans[i][l] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/solution/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/">Krahets题解</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 数组与矩阵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邻接表</title>
      <link href="/2022/09/10/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
      <url>/2022/09/10/%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h1><p>形如<code>1一&gt;3</code>这样的式子是推导式，说明结论1可以推导出结论了。<br />显然这样的推导式具有传递性：<br />如果<code>1一&gt;3</code>且<code>3一&gt;5</code>，那么肯定满足<code>1一&gt;5</code>。<br />现在给出n个推导式，你需要输出结论C能够推导出多少个不同的结论。<br />显然任何结论都可以推导出自己。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入描述：</span><br><span class="line">第一行输入两个整数n和c，含义如题意所述。</span><br><span class="line">接下来n行，每行输入两个整数x，y，表示一个推导式x-&gt;y，可能会出现重复的推导式。</span><br><span class="line">（1 &lt;= n &lt;= 10^5)，（1 &lt;= x,y,c &lt;= 10000）</span><br><span class="line">输出描述：</span><br><span class="line">输出一个整数，表示结论c能推导出的不同结论的数目。</span><br><span class="line"></span><br><span class="line">示例1:</span><br><span class="line">输入：</span><br><span class="line">5 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">3 9</span><br><span class="line">4 2</span><br><span class="line">8 1</span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">说明：</span><br><span class="line">根据推导式1一&gt;2，1一&gt;3，3一&gt;9，可以判断出结论1可以推出结论2，3，9，加上本身总共4个结论。</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><p><strong>算法思路：</strong></p><ol><li>建立哈希表<code>edges</code>，记录每个数字所能推导的结论。</li><li>建立队列<code>que</code>，记录起始结论以及后续推导出的结论。</li><li>建立<code>HashSet</code>集合<code>res</code>，记录最终答案。</li><li>建立哈希表，去除重复，以防循环推导。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; edges = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt(), b = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(!edges.containsKey(a))&#123;</span><br><span class="line">                HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//如果key没记录过，则新建set添加</span></span><br><span class="line">                set.add(b);</span><br><span class="line">                edges.put(a, set);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!edges.get(a).contains(b))&#123;</span><br><span class="line">                    edges.get(a).add(b);<span class="comment">//若key记录过，则直接添加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        que.add(c);</span><br><span class="line">        HashSet&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        res.add(c);</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> que.peek();<span class="comment">//记录当前结论</span></span><br><span class="line">            que.poll();<span class="comment">//将当前结论出队列</span></span><br><span class="line">            map.put(curr, map.getOrDefault(curr, <span class="number">0</span>) + <span class="number">1</span>);<span class="comment">//记录次数</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(curr) != <span class="number">1</span>)<span class="keyword">continue</span>;<span class="comment">//如果不是第一次用，则跳出本次循环</span></span><br><span class="line">            <span class="keyword">if</span>(!edges.containsKey(curr))<span class="keyword">continue</span>;<span class="comment">//如果该结论没有推导结论，则跳出本次循环</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i: edges.get(curr))&#123;<span class="comment">//将一个结论的所有可推导出的结论加进que和res</span></span><br><span class="line">                res.add(i);</span><br><span class="line">                que.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://jiankychen.github.io/">jiankychen教你学算法 - 学算法，看我就够了</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邻接表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式</title>
      <link href="/2022/09/02/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/02/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 28.实现strStr()</title>
      <link href="/2022/08/19/LeetCode-28-%E5%AE%9E%E7%8E%B0strStr/"/>
      <url>/2022/08/19/LeetCode-28-%E5%AE%9E%E7%8E%B0strStr/</url>
      
        <content type="html"><![CDATA[<h1 id="实现strstr"><a class="markdownIt-Anchor" href="#实现strstr"></a> 实现strStr()</h1><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：haystack = <span class="string">&quot;sadbutsad&quot;</span>, needle = <span class="string">&quot;sad&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">&quot;sad&quot;</span> 在下标 <span class="number">0</span> 和 <span class="number">6</span> 处匹配。</span><br><span class="line">第一个匹配项的下标是 <span class="number">0</span> ，所以返回 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><h1 id="方法kmp算法"><a class="markdownIt-Anchor" href="#方法kmp算法"></a> 方法：KMP算法</h1><p><strong>算法思路：</strong></p><ol><li><p>构建<code>next</code>数组。<code>next</code>数组是前缀表，记录下标<code>i</code>之前（包括<code>i</code>）的字符串中，有多大长度的相同前缀后缀。</p><img src="/2022/08/19/LeetCode-28-%E5%AE%9E%E7%8E%B0strStr/KMP%E7%B2%BE%E8%AE%B28.png" class="" title="KMP精讲8"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">//i，j两个指针</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) != needle.charAt(j) &amp;&amp; j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];    <span class="comment">//当i，j指针所指不相等，且j ！= 0，则j跳到前一位记录的下标</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needle.charAt(i) != needle.charAt(j) &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                next[i] = <span class="number">0</span>;<span class="comment">//当i，j指针所指不相等，且j == 0，记录next[i] = 0</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                next[i] = j + <span class="number">1</span>;    <span class="comment">//当i，j指针所指相等，记录next[i] = j + 1，i和j后移一位</span></span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>根据<code>next</code>数组遍历<code>hayStack</code>和<code>needle</code>字符串。</p><img src="/2022/08/19/LeetCode-28-%E5%AE%9E%E7%8E%B0strStr/KMP%E7%B2%BE%E8%AE%B22-20220919180120225.gif" class="" title="KMP精讲2"></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(i) != needle.charAt(j) &amp;&amp; j != <span class="number">0</span>)&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(needle.charAt(i) != needle.charAt(j) &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">                next[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(needle.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">                next[i] = j + <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; haystack.length(); a++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(haystack.charAt(a) != needle.charAt(b) &amp;&amp; b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                b = next[b - <span class="number">1</span>];    <span class="comment">//当a，b指针所指不相等，且b ！= 0，则b跳到前一位记录的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(a) == needle.charAt(b))&#123;</span><br><span class="line">                b++;<span class="comment">//当a，b指针所指相等，a和b后移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b == needle.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> a - needle.length() + <span class="number">1</span>;<span class="comment">//当遍历完needle，说明找到相等子串，返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html">代码随想录 - 实现strStr</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积运算</title>
      <link href="/2022/08/18/%E5%8D%B7%E7%A7%AF%E8%BF%90%E7%AE%97/"/>
      <url>/2022/08/18/%E5%8D%B7%E7%A7%AF%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="卷积运算"><a class="markdownIt-Anchor" href="#卷积运算"></a> 卷积运算</h1><p>卷积神经网络使用卷积操作来提取特征，卷积一般包含以下几个概念：</p><ol><li>输入：一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>大小的矩阵，是一个二维数组，是图像的数据信息。</li><li>卷积核：一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∗</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">k*l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>大小的矩阵，是一个二维数组，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>为奇数，保证卷积核有一个中心。</li><li>卷积操作：将卷积核的中心对准输入的某个元素，两个矩阵的重合区域中的对应元素相乘后求和，得到输出数组中对应元素的数据。</li><li>输出：将卷积核滑动过程的卷积结果按照顺序放入一个二维数组中，即图像卷积的输出。</li><li>滑动步长：卷积核每次滑动的距离，本题中为1。</li><li>本题中，当输出中元素小于0时要变更为0，当输出中的元素大于255时要变更为255。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">第一行为M、N、K、L，后为图像矩阵和卷积矩阵。</span><br><span class="line">5 6 3 3</span><br><span class="line">1 1 1 1 1 1</span><br><span class="line">1 2 2 2 2 1</span><br><span class="line">2 3 3 1 2 2</span><br><span class="line">1 2 2 3 4 5</span><br><span class="line">5 6 6 6 3 4</span><br><span class="line">1 10 1</span><br><span class="line">1 20 1</span><br><span class="line">1 8 1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">31 41 42 42 41 31</span><br><span class="line">52 84 84 69 74 51</span><br><span class="line">65 107 109 79 106 98</span><br><span class="line">91 137 139 138 145 161</span><br><span class="line">118 154 157 165 118 137</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">K</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] pic = <span class="keyword">new</span> <span class="title class_">int</span>[M][N];</span><br><span class="line">        <span class="type">int</span>[][] core = <span class="keyword">new</span> <span class="title class_">int</span>[K][L];</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[M][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                pic[i][j] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; L; j++) &#123;</span><br><span class="line">                core[i][j] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                ans[i][j] = helper(pic, core, i, j, M, N, K, L);</span><br><span class="line">                <span class="keyword">if</span>(ans[i][j] &lt; <span class="number">0</span>)ans[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(ans[i][j] &gt; <span class="number">255</span>)ans[i][j] = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                System.out.print(ans[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[][] pic, <span class="type">int</span>[][] core, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> K, <span class="type">int</span> L)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> - K / <span class="number">2</span>; i &lt;= K / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> - L / <span class="number">2</span>; j &lt;= L / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x + i &lt; <span class="number">0</span> || x + i &gt; M - <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(y + j &lt; <span class="number">0</span> || y + j &gt; N - <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                res += pic[x + i][y + j] * core[i + K / <span class="number">2</span>][j + L / <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://jiankychen.github.io/">jiankychen教你学算法 - 学算法，看我就够了</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习之路</title>
      <link href="/2022/08/15/Redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/2022/08/15/Redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> redis</h1><p>基本概念：Redis（Remote Dictionary Server），即远程字典服务，是基于内存的（Mysql基于硬盘），Key-Value数据库，是NoSQL（非关系型数据库）。</p><ol><li><p><strong>支持的数据类型</strong></p><p><code>Key</code>仅支持<code>String</code>类型，而<code>Value</code>支持多种类型：</p><ul><li><code>String</code>：采用类似数组的形式储存。</li><li><code>List</code>：双向链表实现。</li><li><code>Hash</code>：基于拉链法实现，储存时将<code>index</code>和<code>00000011</code>相与，去最后两位，以防超出限制。</li><li><code>Set</code>：不重复的集合。</li><li><code>Sorted Set</code>：多了一个权重参数<code>score</code>，集合内元素能够按<code>score</code>进行排列。</li></ul></li><li><p><strong>持久化</strong></p><ul><li><code>RDB</code>（Redis DataBase）：把目前<code>redis</code>内存中的数据，生成一个快照（RDB文件），保存在硬盘中，如果发生事故，<code>redis</code>可以通过<code>RDB</code>文件，进行文件读取，并将数据重新载入内存中，是一种全量备份。<ul><li>可手动触发（<code>save</code>命令、<code>bgsave</code>——会<code>fork</code>一个子进程去执行）</li><li>可自动触发（配置文件写入save m n，代表m秒内发生n次变化，会自动执行bgsave）。</li></ul></li><li><code>AOF</code>：记录之后所有对<code>redis</code>数据进行修改的操作。如果发生事故，<code>redis</code>可以通过<code>AOF</code>文件，将文件中的数据修改命令全部执行一遍，一次恢复数据。<ul><li><code>AOF</code>重写，根据当前<code>Redis</code>数据状态生成新<code>AOF</code>文件，替换原本冗余的<code>AOF</code>文件。可手动触发：<code>bgrewriteaof</code>或自动触发：配置文件设置<code>appendonly yes</code>开启。</li></ul></li></ul></li><li><p><strong>缓存</strong></p><ul><li><p><strong>缓存淘汰：</strong></p><p>三种算法：先进先出FIFO、最近最少使用LRU（可以双向链表+哈希表实现：当某个key被访问到了，程序通过哈希表迅速定位节点，并将该节点移至链表开头）、最不经常使用LFU。</p></li><li><p><strong>过期删除：</strong></p><ol><li>主动删除：设置删除时间间隔，在指定时间后进行主动删除工作。</li><li>惰性删除：程序取值时查看该数据是否过期，如果没过期，则返回；如果过期，则删除。</li><li>定期删除：每隔一段时间，执行主动删除，不跑主动删除时，则执行惰性删除。</li></ol></li><li><p><strong>缓存一致（Cache Aside）</strong></p></li><li><p>**缓存击穿：**查询某个数据的值，该值不在缓存中，在数据库中有。</p><p><strong>解决方法：</strong></p><ol><li>从MySQL出发，加锁，减少击穿后的直接流量</li><li>从Redis出发，设置热点数据永不过期，或热点数据后台启动一个一步线程，重新把数据回填缓存层</li></ol></li><li><p>**缓存穿透：**查询一个缓存和数据库都不存在的数据。</p><p><strong>解决方法：</strong></p><ol><li>对数据库访问前进行校验，对数据库拦截非法查询请求。</li><li>对于经常被访问的，并且数据库中没有的键，缓存层记录键 = null。</li><li>布隆过滤器：设置k个各不相同的hash映射函数，把在数据库中的有效数据通过这个映射函数得到数组指定位置，并置为1。当输入查询数据的时候，计算这k个hash函数，如果有一位是0，则一定是无效查询。</li></ol></li><li><p>**缓存雪崩：**一大批被缓存的数据，同时失效，这批数据请求全部打到数据库，导致宕机。可以看作多条数据的缓存击穿。</p><p><strong>解决方法（和缓存击穿类似）：</strong></p><ol><li>从MySQL出发，加锁，减少击穿后的直接流量</li><li>从Redis出发，设置热点数据永不过期，或热点数据后台启动一个一步线程，重新把数据回填缓存层</li><li>分析失效时间，尽量让失效时间点分散</li><li>对于集群部署的情况，将热点数据分布在不同缓存中</li></ol></li></ul></li><li><p><strong>集群</strong></p><ul><li><p><strong>主从复制：</strong></p><p>有主库（Master）节点和从库（Slave）节点两个角色，写操作作用于主库，读操作作用于从库（可多加几台从库），读写分离。</p><ul><li><p>全量复制：主库执行<code>BGSAVE</code>，生成对应的RDB文件，同时开辟缓存区，是为了记录在RDB文件实行过程中，收到的新数据命令。RDB文件产生后，主库发给从库，从库通过RDB恢复数据。后面主库会把数据变更命令发给从库，从库收到后执行。</p></li><li><p>断线后重复制:需确定以下信息</p><ol><li>服务器运行id：唯一确定主库身份，以防更换了主库，更换了以后只能全量复制</li><li>复制偏移量：从主节点传输了的字节数</li><li>复制积压缓冲区：这里储存的是最近主节点的数据修改命令</li></ol></li></ul></li><li><p><strong>哨兵机制：</strong></p><p>建立哨兵组（不提供数据服务的<code>redis</code>服务器），对主库从库统一进行监控，如果主库坏了，哨兵组进行投票，从从库中重新选出主库。</p><p>每个哨兵每十秒向主库、从库和其他哨兵发送<code>ping</code>，若有哨兵发现主库连接不上，会将其主观下线，并通知其他哨兵<code>ping</code>。若超过半数连接不上，则将其客观下线，执行故障转移，在从库中选个新主库（会选一个老大哨兵，主持新主库的选举）。</p><p>若老主库重新上线，则退化为从库。</p></li><li><p><strong>Cluster集群：</strong></p><p>自动将你的数据切分给多个节点储存，及时这些节点中一部分宕机，也可以继续执行数据操作。</p><p><strong>分区策略</strong>：所有键通过CRC16校验函数，对16384取模，分配到不同槽位，每个<code>redis</code>的<code>cluster</code>节点负责一部分槽数据的储存。</p><p><strong>查询策略</strong>：每个节点都会储存整个集群节点信息，这些信息也被称为元信息。如果执行<code>get</code>操作，节点先验证该<code>key</code>对应的槽编号是不是归本节点关，如果是则保存数据，否则发送正确的节点编号给客户端。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 494.目标和</title>
      <link href="/2022/08/11/LeetCode-494-%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
      <url>/2022/08/11/LeetCode-494-%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="目标和"><a class="markdownIt-Anchor" href="#目标和"></a> 目标和</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><h1 id="0-1背包"><a class="markdownIt-Anchor" href="#0-1背包"></a> 0 - 1背包</h1><p><strong>算法思路：</strong></p><p>要使表达式结果为<code>target</code>，可将式子分为加法部分<code>plus</code>和减法部分<code>neg</code>，根据<code>neg = sum - plus</code>和<code>plus - neg = target</code>可得，<code>plus = (target + sum) / 2</code>。问题就转化为装满容量为<code>plus</code>的背包，有几种方法（组合问题）。</p><ol><li><p>循环前进行前置判断。当<code>target + sum</code>不能被二整除，以及<code>plus &lt; 0</code>时，没有方案，返回<code>0</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((target + sum) % <span class="number">2</span> != <span class="number">0</span> || (target + sum) &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>确定dp数组以及下标的含义</p><p><code>dp[j]</code>表示，填满<code>j</code>（包括<code>j</code>）这么大容积的包，有<code>dp[j]</code>种方法。</p></li><li><p>确定递推公式</p><p>不考虑<code>nums[i]</code>的情况下，填满容量为<code>j</code>的背包，有<code>dp[j]</code>种方法。</p><p>那么考虑<code>nums[i]</code>的话（只要搞到<code>nums[i]</code>），凑成<code>dp[j]</code>就有<code>dp[j - nums[i]]</code> 种方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：dp[j]，j 为5，</span><br><span class="line"></span><br><span class="line">已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。</span><br><span class="line">已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。</span><br><span class="line">已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]</span><br><span class="line">已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]</span><br><span class="line">已经有一个5（nums[i]）的话，有 dp[0]中方法 凑成 dp[5]</span><br><span class="line">那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</span><br></pre></td></tr></table></figure><p><strong>所以求组合类的公式，都是类似<code>dp[j] += dp[j - nums[i]]</code>。</strong></p></li><li><p>dp数组初始化</p><p><code>dp[0] = 1</code>，装满容量为<code>0</code>的背包，有<code>1</code>种方法，就是装<code>0</code>件物品。</p></li><li><p>确定遍历顺序</p><p>先遍历物品<code>nums[i]</code>，再遍历背包<code>j</code>。</p></li><li><p>举例推导dp数组</p><img src="/2022/08/11/LeetCode-494-%E7%9B%AE%E6%A0%87%E5%92%8C/20210125120743274.jpg" class="" title="494.目标和"></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((target + sum) % <span class="number">2</span> != <span class="number">0</span> || (target + sum) &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">plus</span> <span class="operator">=</span> (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[plus + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> plus; j &gt;= nums[i]; j--)&#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[plus];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#_494-%E7%9B%AE%E6%A0%87%E5%92%8C">代码随想录 - 目标和</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 0-1背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 416.分割等和子集</title>
      <link href="/2022/08/10/LeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
      <url>/2022/08/10/LeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="分割等和子集"><a class="markdownIt-Anchor" href="#分割等和子集"></a> 分割等和子集</h1><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure><h1 id="方法一0-1背包"><a class="markdownIt-Anchor" href="#方法一0-1背包"></a> 方法一：0 - 1背包</h1><p><strong>算法思路：</strong></p><p>背包问题为，有<code>N</code>件物品和一个最多能背重量为<code>W</code>的背包，第<code>i</code>件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code>，每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><p>明确以下四点，才能把01背包问题套到本题上来（只能放入一次是01背包，能重复多次放入是完全背包）：</p><ul><li><p>背包的体积为<code>sum / 2</code></p></li><li><p>背包要放入的商品（集合里的元素），<strong>重量为元素的数值，价值也为元素的数值</strong></p></li><li><p>背包如果正好装满，说明找到了总和为<code>sum / 2</code>的子集</p></li><li><p>背包中每一个元素是不可重复放入</p></li></ul><p>确定可以套用，则动态规划五部曲：</p><ol><li><p>确定dp数组以及下标的含义</p><p><code>dp[i][j]</code>代表可装物品为0 - i，背包容量为<code>j</code>的情况下，背包内容量的最大值。</p></li><li><p>确定递推公式</p><p>当能放的下<code>nums[i]</code>的时候，比较放还是不放，谁的值比较大。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(j &gt;= nums[i])&#123;</span><br><span class="line">           dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - nums[i]] + nums[i]);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>dp数组的初始化</p><p><code>dp[0][i]</code>表示不放物品，价值为<code>0</code>。</p><p><code>dp[o][j]</code>表示只放第一个物品，价值为<code>nums[0]</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums[<span class="number">0</span>]; j &lt;= target; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>确定遍历顺序</p><p>先遍历物品<code>i</code>，再遍历背包<code>j</code>。</p></li><li><p>举例推导dp数组</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">10</td><td style="text-align:center">11</td></tr></tbody></table></li></ol><p><strong>算法实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length][target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums[<span class="number">0</span>]; j &lt;= target; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= target; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= nums[i])&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - nums[i]] + nums[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>][target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二一维数组0-1背包"><a class="markdownIt-Anchor" href="#方法二一维数组0-1背包"></a> 方法二：一维数组0 - 1背包</h1><p><strong>算法思路：</strong></p><p>动态规划五部曲：</p><ol><li><p>确定dp数组以及下标的含义</p><p><code>dp[j]</code>代表背包容量为<code>j</code>的情况下，背包内容量的最大值。</p></li><li><p>确定递推公式</p><p>和二维数组不同，这里不用比较，因为<code>j</code>的范围使得<code>nums[i]</code>肯定能放下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br></pre></td></tr></table></figure></li><li><p>dp数组的初始化</p><p><code>dp[0]</code>表示不放物品，价值为<code>0</code>。</p><p>如果题目给的价值都是正整数，那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么0的下标就要初始化为负无穷。这样才能在递归中取得最大价值，而不会被出示值覆盖。</p></li><li><p>确定遍历顺序</p><p>先遍历物品<code>i</code>，再遍历背包<code>j</code>，且内层for循环倒序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= nums[i]; j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>举例推导dp数组</p><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">10</td><td style="text-align:center">11</td></tr></tbody></table></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= nums[i]; j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">代码随想录 - 分割等和子集</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 0-1背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些面试题</title>
      <link href="/2022/08/07/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/08/07/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="哈夫曼树和哈夫曼编码"><a class="markdownIt-Anchor" href="#哈夫曼树和哈夫曼编码"></a> 哈夫曼树和哈夫曼编码</h1><p><strong>定义</strong>：当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”，哈夫曼树<strong>不唯一</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。</span><br><span class="line">下面树的WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3</span><br></pre></td></tr></table></figure><img src="/2022/08/07/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/09563Tb0-0.png" class="" title="img"><p><strong>构造哈夫曼树</strong>：以2，6，8，9，3为例。</p><ol><li><p>选最小的两个数，构建树，排序</p><img src="/2022/08/07/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/b64543a98226cffcc27855142d7efb98f703ea4b.jpeg" class="" title="img"></li><li><p>重复上述操作，如果有相同的值，谁前谁后无所谓，最后<code>WPL</code>值一样。</p><img src="/2022/08/07/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/8c1001e93901213f9f7b6ae1c09887d92e2e95ce.jpeg" class="" title="img"><img src="/2022/08/07/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/b17eca8065380cd76176a04e303b1c3c588281b5.jpeg" class="" title="img"></li></ol><p><strong>哈夫曼编码</strong>：二叉树往左边为0，往右边为1，即可得到每个树的编码。</p><img src="/2022/08/07/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/0b46f21fbe096b63560b3742954c364cebf8ac1e.jpeg" class="" title="img">]]></content>
      
      
      <categories>
          
          <category> 八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 260.只出现一次的数字III</title>
      <link href="/2022/08/03/LeetCode-260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/"/>
      <url>/2022/08/03/LeetCode-260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III/</url>
      
        <content type="html"><![CDATA[<h1 id="只出现一次的数字iii"><a class="markdownIt-Anchor" href="#只出现一次的数字iii"></a> 只出现一次的数字III</h1><p>给你一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,1,3,2,5]</span><br><span class="line">输出：[3,5]</span><br><span class="line">解释：[5,3] 也是有效的答案。</span><br></pre></td></tr></table></figure><h1 id="方法位运算"><a class="markdownIt-Anchor" href="#方法位运算"></a> 方法：位运算</h1><p><strong>算法思路：</strong></p><ol><li>异或运算<code>^</code>，相同的两个数之间异或为<code>0</code>。将数组每一个数进行异或，得到两个只出现一次元素的异或值<code>diff</code>。</li><li><code>n &amp; (-n)</code>，可得<code>n</code>的位级表示中最低的那一位<code>1</code>。计算<code>diff = diff * - diff</code>，得到<code>diff</code>的最低一位<code>1</code>，即两个只出现一次的元素在该位上不同。</li><li>通过<code>diff &amp; num</code>是否等于<code>0</code>将数组中的元素分类两类，分开异或，即可得到两个只出现一次的元素。</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            diff ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        diff &amp;= - diff;</span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((diff &amp; num) == <span class="number">0</span>)&#123;  <span class="comment">//运算的括号不能省</span></span><br><span class="line">                ret[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ret[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是数组<code>nums</code>的长度。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h1><p><a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BD%8D%E8%BF%90%E7%AE%97.html#_4-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0">Leetcode题解 - 位运算</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发</title>
      <link href="/2022/08/01/Java%E5%B9%B6%E5%8F%91/"/>
      <url>/2022/08/01/Java%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的六种状态"><a class="markdownIt-Anchor" href="#线程的六种状态"></a> 线程的六种状态</h1><img src="/2022/08/01/Java%E5%B9%B6%E5%8F%91/image-20220829223910101.png" class="" title="image-20220829223910101"><h1 id="线程池的核心参数"><a class="markdownIt-Anchor" href="#线程池的核心参数"></a> 线程池的核心参数</h1><p>线程池可以看做是线程的集合。在没有任务时线程处于空闲状态，当请求到来：线程池给这个请求分配一个空闲的线程，任务完成后回到线程池中等待下次任务执行(而不是销毁)。这样就实现了线程的重用。如果请求到来时，核心线程被占用，任务便会进入<code>workQueue</code>中等待。若<code>workQueue</code>也满，则会创建救急线程来执行，执行完任务后，救急线程不会保留在线程池中，有一定的生存时间，取决于<code>keepAliveTime</code>与<code>unit</code>。若还有时间，会从<code>workQueue</code>中依次加载任务。</p><img src="/2022/08/01/Java%E5%B9%B6%E5%8F%91/image-20220830210208314.png" class="" title="image-20220830210208314"><ol><li><strong>corePoolSize核心线程数目</strong>：最多保留的线程数。</li><li><strong>maximumPoolSize最大线程数目</strong>：核心线程+救急线程。</li><li><strong>keepAliveTime生存时间</strong>：针对救急线程。</li><li><strong>unit时间单位</strong>：针对救急线程。</li><li><strong>workQueue</strong> ：阻塞队列。</li><li><strong>threadFactory线程工厂</strong>：可以为线程创建时起个好名字。</li><li><strong>handler拒绝策略</strong>：当核心线程、救急线程、阻塞队列都满是，<code>submit</code>一个任务，则会触发拒绝策略。<ul><li>默认为<code>AbortPolicy</code>，会抛出异常。</li><li><code>CallerRunsPolicy</code>，由提交任务的线程完成任务（如main线程）。</li><li><code>DiscardPolicy</code>，丢弃，不运行，也不报错。</li><li><code>DiscardOldestPolicy</code>，抛弃队列中最先加入的任务，新任务进入队列。</li></ul></li></ol><h2 id="代码演示"><a class="markdownIt-Anchor" href="#代码演示"></a> 代码演示</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWaiting</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            logger1.debug(<span class="string">&quot;before waiting&quot;</span>); <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOCK.wait(); <span class="comment">// 3</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t2.start();</span><br><span class="line">    main.debug(<span class="string">&quot;state: &#123;&#125;&quot;</span>, t2.getState()); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">        main.debug(<span class="string">&quot;state: &#123;&#125;&quot;</span>, t2.getState()); <span class="comment">// 4</span></span><br><span class="line">        LOCK.notify(); <span class="comment">// 5</span></span><br><span class="line">        main.debug(<span class="string">&quot;state: &#123;&#125;&quot;</span>, t2.getState()); <span class="comment">// 6</span></span><br><span class="line">    &#125;</span><br><span class="line">    main.debug(<span class="string">&quot;state: &#123;&#125;&quot;</span>, t2.getState()); <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">[DEBUG] <span class="number">21</span>:<span class="number">10</span>:<span class="number">51.829</span> [t2] - before waiting </span><br><span class="line">[DEBUG] <span class="number">21</span>:<span class="number">10</span>:<span class="number">51.829</span> [main] - state: RUNNABLE </span><br><span class="line">[DEBUG] <span class="number">21</span>:<span class="number">11</span>:<span class="number">03.137</span> [main] - state: WAITING </span><br><span class="line">[DEBUG] <span class="number">21</span>:<span class="number">11</span>:<span class="number">04.051</span> [main] - state: BLOCKED </span><br><span class="line">[DEBUG] <span class="number">21</span>:<span class="number">11</span>:<span class="number">05.195</span> [main] - state: RUNNABLE </span><br></pre></td></tr></table></figure><ol><li><code>t2.start()</code>启动线程，t2线程变为<code>runnable</code>状态，线程进入代码块</li><li>t2线程执行<code>wait()</code>方法后，锁释放，主线程进入<code>sychronized</code>代码块</li><li>主线程调用<code>notify()</code>方法，打印t2线程状态，为<code>blocked</code>，因为锁被主线程占有</li><li>主线程执行完<code>sychronized</code>代码块，t2线程继续运行，状态变为<code>runnable</code></li></ol><h1 id="sleep-vs-wait"><a class="markdownIt-Anchor" href="#sleep-vs-wait"></a> sleep vs wait</h1><ul><li><strong>共同点：</strong><code>wait()</code>、<code>wait(long)</code>和<code>sleep(long)</code>的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态。</li><li><strong>方法归属不同：</strong><ol><li><code>sleep(long)</code>是<code>Thread</code>的静态方法</li><li><code>wait()</code>、<code>wait(long)</code>都是<code>Object</code>的成员方法，每个对象都有</li></ol></li><li><strong>醒来时机不同：</strong><ol><li>执行<code>sleep(long)</code>和<code>wait(long)</code>的线程都会在等待相应毫秒后醒来</li><li><code>wait(long)</code>和<code>wait()</code>还可以被<code>notify</code>唤醒，<code>wait()</code>如果不唤醒就一直等下去</li><li>它们都可以被线程对象的<code>interrupt()</code>打断唤醒，被打断的线程抛出异常</li></ol></li><li><strong>锁特性不同：</strong><ol><li><code>wait()</code>方法的调用必须先获取wait对象的锁，而<code>sleep()</code>无此限制</li><li><code>wait()</code>方法执行后会释放对象锁，允许其他线程获得该对象锁（我放弃，但你们还可以用）</li><li>而<code>sleep()</code>如果在synchronized代码块中执行，并不会释放对象锁（我放弃，你们也用不了）</li></ol></li></ul><h1 id="lock-vs-synchronized"><a class="markdownIt-Anchor" href="#lock-vs-synchronized"></a> lock vs synchronized</h1><ul><li><strong>语法层面</strong><ul><li><code>synchronized</code>是关键字，源码在jvm中，用c++语言实现</li><li><code>Lock</code>是接口，源码由jdk提供，用java语言实现</li><li>使用<code>synchronized</code>时，退出同步代码块锁会自动释放，而使用<code>Lock</code>时，需要手动调用<code>unlock</code>方法释放锁</li></ul></li><li><strong>功能层面</strong><ul><li>二者均属于悲观锁，都具备基本的互斥、同步、锁重入功能<ul><li><strong>互斥</strong>：多个线程争抢一把锁，只有一个线程成功，其余锁进入阻塞状态</li><li><strong>同步</strong>：多线程同步运行，当某一线程需要另一线程的计算结果，那么它会等待那个线程运行完再运行下去</li><li><strong>锁重入</strong>：可以给同一对象加多道锁（加多道，解锁时也要解多道）</li></ul></li><li><code>Lock</code>提供了许多<code>synchronized</code>不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量（因为<code>synchronized</code>用c++实现，较为底层）<ul><li>获取等待状态：互斥、同步时，可以知道哪些线程处于阻塞状态、等待状态</li><li>公平锁：多线程争抢锁失败后，后续再获得锁时，若先来先得为公平锁，可插队为非公平锁<ul><li><code>Lock</code>可以公平锁也可以非公平锁，而<code>synchronized</code>为非公平锁</li><li>非公平锁吞吐量高，插队效率更高</li></ul></li><li>可打断、可超时：锁被线程占用，其他线程的等待过程可以被打断，或者设置超时时间，<code>synchronized</code>则一直等下去</li><li>多条件变量：<code>Lock</code>有多个等待队列（<code>await()</code>方法使线程进入waiting queue，<code>signal()</code>方法唤醒，<code>synchronized</code>只有一个</li></ul></li><li><code>Lock</code>有适合不同场景的实现，如<code>ReentrantLock</code>（可重入锁），<code>ReentrantReadWriteLock</code>（针对读多写少），<code>synchronized</code>只有一层实现，即用c++语言在jvm底层实现</li></ul></li><li><strong>性能层面</strong><ul><li>在没有竞争时，<code>synchronized</code>做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，<code>Lock</code>的实现通常会提供更好的性能</li></ul></li></ul><h1 id="volatile修饰符能否保证线程安全"><a class="markdownIt-Anchor" href="#volatile修饰符能否保证线程安全"></a> volatile（修饰符）能否保证线程安全</h1><ol><li><p>线程安全要考虑三个方面：可见性、有序性、原子性，<code>volatile</code>可以保证可见性和有序性。</p><ul><li><p>**可见性：**一个线程对共享变量修改，另一个线程能看到最新的结果。</p></li><li><p>**有序性：**一个线程内代码安编写顺序执行。假如你编写顺序是123，但cpu对你优化，变为321执行，这对单线程没问题，对多线程可能会有问题。</p></li><li><p>**原子性：**一个线程内多行代码以一个整体运行，期间不能有其他线程的代码插队。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subtract</span><span class="params">()</span>&#123;</span><br><span class="line">  balance -= <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">  balance += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用两个线程执行加减操作，执行<code>javap -p - v ( + *.class字节码文件)</code>，查看反编译内容。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1</span><br><span class="line">0:getstatic</span><br><span class="line">3:iconst_5</span><br><span class="line">4:iadd</span><br><span class="line">5:putstatic</span><br><span class="line"></span><br><span class="line">t2</span><br><span class="line">0:getstatic</span><br><span class="line">3:iconst_5</span><br><span class="line">4:isub</span><br><span class="line">5:putstatic</span><br></pre></td></tr></table></figure><p>可以看出<code>balance += 5</code>一条代码，对应底层多行操作，若两个线程执行各自的多行代码时发生交错，则可能导致最后结果出错。所以要保证原子性，可用<code>synchronized</code>、<code>lock锁</code>、<code>CAS</code>。</p><ul><li><code>CAS</code>原理：比较并交换，如果我们读到的值<code>v</code>和调用<code>weakCompareAndSetInt</code>中快照获取的内存中的值一致的话，那么我们就将变更后的值进行写入到主内存中的操作进行下去；如果预期值与实际的值不一致（即已经有其他的线程捷足先登，提前改变了这个值，那么我们再取主内存中最新的值，进行循环的比较与交换操作）。</li></ul></li></ul></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 39.组合总和</title>
      <link href="/2022/07/28/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>/2022/07/28/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="组合总和"><a class="markdownIt-Anchor" href="#组合总和"></a> 组合总和</h1><p>给你一个<strong>无重复元素</strong>的整数数组<code>candidates</code>和一个目标整数<code>target</code>，找出<code>candidates</code>中可以使数字和为目标数<code>target</code>的<strong>所有</strong>不同组合 ，并以列表形式返回。你可以按<strong>任意顺序</strong>返回这些组合。</p><p><code>candidates</code>中的<strong>同一个</strong>数字可以<strong>无限制重复被选取</strong>。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 target 的不同组合数少于<code>150</code>个。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><h1 id="方法一回溯"><a class="markdownIt-Anchor" href="#方法一回溯"></a> 方法一：回溯</h1><p><strong>算法思路：</strong></p><p>本题和<a href="https://abacteria.github.io/2022/07/25/LeetCode-77-%E7%BB%84%E5%90%88/">77.组合 (opens new window)</a>，<a href="https://abacteria.github.io/2022/07/26/LeetCode-216-%E7%BB%84%E5%90%88III/">216.组合总和III (opens new window)</a>和区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p><img src="/2022/07/28/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/20201223170730367.png" class="" title="39.组合总和"><ol><li><p>确定递归函数的返回值以及参数</p><p>除了题中输入<code>candidates</code>和<code>target</code>外，还需要定义<code>sum</code>来记录<code>path</code>中的总和。</p><p><code>startIndex</code>的设置（仅针对求组合问题，排列问题不一样）：</p><ul><li>如果是一个集合来求组合的话，就需要<code>startIndex</code>，如<a href="https://abacteria.github.io/2022/07/25/LeetCode-77-%E7%BB%84%E5%90%88/">77.组合 (opens new window)</a>，<a href="https://abacteria.github.io/2022/07/26/LeetCode-216-%E7%BB%84%E5%90%88III/">216.组合总和III (opens new window)</a>。</li><li>如果是多个集合取组合，各个集合之间相互不影响，就不需要设置<code>startIndex</code>，如<a href="https://abacteria.github.io/2022/07/27/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/">17.电话号码的字母组合</a></li></ul></li><li><p>确定终止条件</p><p>当<code>sum</code>大于等于<code>target</code>时终止递归，当<code>sum</code>等于<code>target</code>时，将<code>path</code>添加到<code>result</code>中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">      <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">          result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单层搜索的过程</p><p>单层<code>for</code>循环依然是从<code>startIndex</code>开始，搜索<code>candidates</code>集合。此处需要注意元素可以重复选取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backTracking(candidates, target, sum, i);<span class="comment">//可以重复选取元素，所以不用i+1</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        backTracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backTracking(candidates, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二剪枝优化"><a class="markdownIt-Anchor" href="#方法二剪枝优化"></a> 方法二：剪枝优化</h1><img src="/2022/07/28/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/20201223170809182.png" class="" title="39.组合总和1"><p>对于排序数组<code>candidates</code>，当<code>sum + candidates[i] &gt; target</code>时，后续的数就不需要遍历了，直接<code>break</code>。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);<span class="comment">//排序</span></span><br><span class="line">        backTracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//若超出范围，则跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backTracking(candidates, target, sum, i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">代码随想录 - 组合总和</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 40.组合总和II</title>
      <link href="/2022/07/28/LeetCode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/"/>
      <url>/2022/07/28/LeetCode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/</url>
      
        <content type="html"><![CDATA[<h1 id="组合总和ii"><a class="markdownIt-Anchor" href="#组合总和ii"></a> 组合总和II</h1><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p>**注意：**解集不能包含重复的组合。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="方法回溯"><a class="markdownIt-Anchor" href="#方法回溯"></a> 方法：回溯</h1><p><strong>算法思路：</strong></p><p>与<strong>39.组合总和</strong>不同的是，本题<code>candidates</code>的元素是有重复的，每个数字在每个组合中只能使用一次。所以，我们需要对同一树层上使用过的元素去重，同一树枝上的不需要去重。</p><img src="/2022/07/28/LeetCode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/20201123202736384.png" class="" title="40.组合总和II"><ol><li><p>确定递归函数参数</p><p>除<strong>39.组合总和</strong>设置的参数外，还需加一个<strong>boolean</strong>型数组<code>used</code>，用来记录同一树层上的元素是否使用过。</p></li><li><p>确定递归终止条件</p><p>当<code>sum</code>大于等于<code>target</code>时终止递归，当<code>sum</code>等于<code>target</code>时，将<code>path</code>添加到<code>result</code>中。剪枝优化可参考<strong>39.组合总和</strong>，先将<code>candidates</code>数组排序，当<code>sum + candidates[i] &gt; target</code>时，后续的数就不需要遍历了，直接<code>break</code>。</p></li><li><p>单层搜索的过程</p><p><code>for</code>循环从<code>startIndex</code>开始，搜索<code>candidates</code>数组，若遇到重复的，则直接<code>continue</code>跳过。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backTracking(candidates, target, sum, i + <span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">代码随想录 - 组合总和II</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 131.分割回文串</title>
      <link href="/2022/07/27/LeetCode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2022/07/27/LeetCode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="分割回文串"><a class="markdownIt-Anchor" href="#分割回文串"></a> 分割回文串</h1><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><h1 id="方法回溯"><a class="markdownIt-Anchor" href="#方法回溯"></a> 方法：回溯</h1><p><strong>算法思路：</strong></p><p>切割问题类似于组合问题，例如对于字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个……。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段……。</li></ul><img src="/2022/07/27/LeetCode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" class="" title="131.分割回文串"><ol><li><p>确定递归函数参数</p><p>除了输入的字符串<code>s</code>外，还需设置<code>startIndex</code>记录切割过的位置，不能重复切割。</p></li><li><p>确定终止条件</p><p>当切割线到字符串最后面，即<code>startIndex == s.size()</code>时，终止递归。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(startIndex == s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>编写判断是否为回文串的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(startIndex &lt; end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(startIndex++) != s.charAt(end--))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单层搜索的过程</p><p>判断<code>startIndex</code>到<code>i</code>的子串是否为回文串，若是则加到<code>path</code>中，否则<code>continue</code>结束本次<code>for</code>循环。</p></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backTracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex == s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, startIndex, i))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(startIndex, i + <span class="number">1</span>);    <span class="comment">//substring不要写错了</span></span><br><span class="line">                path.add(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backTracking(s, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(startIndex &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(startIndex++) != s.charAt(end--))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">代码随想录 - 分割回文串</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 17.电话号码的字母组合</title>
      <link href="/2022/07/27/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
      <url>/2022/07/27/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="电话号码的字母组合"><a class="markdownIt-Anchor" href="#电话号码的字母组合"></a> 电话号码的字母组合</h1><p>给定一个仅包含数字<code>2~9</code>的字符串，返回所有它能表示的字母组合。答案可以按<strong>任意顺序</strong>返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意<code>1</code>不对应任何字母。</p><img src="/2022/07/27/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/200px-telephone-keypad2svg.png" class="" title="img"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><h1 id="方法回溯"><a class="markdownIt-Anchor" href="#方法回溯"></a> 方法：回溯</h1><p><strong>算法思路：</strong></p><ol><li><p>确定递归函数的返回值以及参数</p><p>除了题中输入的<code>digits</code>,还需要定义参数<code>index</code>来记录遍历到<code>digits</code>的第几个数字了，以及需要创建一个数组<code>numString</code>用来记录每个数字对应的字母。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] numString = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>确定终止条件</p><p>当<code>index</code>等于输入数字的个数<code>digits.size()</code>时，收集结果，结束递归。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">    result.add(sb.toString());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单层搜索的过程</p><p>读取<code>index</code>指向的数字，并找到对应的字符集，然后使用<code>for</code>循环来处理这个字符集（遍历字符集的每个字母）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            sb.append(str.charAt(i));</span><br><span class="line">            backTracking(digits, numString, index + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        String[] numString = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        backTracking(digits, numString, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String digits, String[] numString, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numString[digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            sb.append(str.charAt(i));</span><br><span class="line">            backTracking(digits, numString, index + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">代码随想录 - 电话号码的字母组合</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 216.组合III</title>
      <link href="/2022/07/26/LeetCode-216-%E7%BB%84%E5%90%88III/"/>
      <url>/2022/07/26/LeetCode-216-%E7%BB%84%E5%90%88III/</url>
      
        <content type="html"><![CDATA[<h1 id="组合iii"><a class="markdownIt-Anchor" href="#组合iii"></a> 组合III</h1><p>找出所有相加之和为<code>n</code>的<code>k</code>个数的组合，且满足下列条件：</p><ul><li><p>只使用数字1到9</p></li><li><p>每个数字<strong>最多使用一次</strong></p></li></ul><p>返回所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><h1 id="方法一回溯"><a class="markdownIt-Anchor" href="#方法一回溯"></a> 方法一：回溯</h1><p><strong>算法思路：</strong></p><ol><li><p>确定递归函数的返回值以及参数</p><p>除了<code>n</code>与<code>k</code>，我们还需要设置变量<code>sum</code>记录<code>path</code>中元素的和，<code>startIndex</code>记录循环搜索的起始位置</p></li><li><p>确定终止条件</p><p>当<code>path</code>大小达到<code>k</code>时终止递归，若此时<code>path</code>中的元素和为<code>sum</code>等于<code>n</code>，则在<code>result</code>中添加<code>path</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单层搜索的过程</p><p>和77.组合一样，都是从<code>startIndex</code>开始遍历，其中<code>sum</code>来统计<code>path</code>中的元素之和，回溯后需要减回去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backTracking(k, n, i + <span class="number">1</span>, sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backTracking(k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == n)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backTracking(k, n, i + <span class="number">1</span>, sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二-剪枝优化"><a class="markdownIt-Anchor" href="#方法二-剪枝优化"></a> 方法二： 剪枝优化</h1><img src="/2022/07/26/LeetCode-216-%E7%BB%84%E5%90%88III/2020112319580476.png" class="" title="216.组合总和III1"><p>当元素总和已经大于<code>n</code>时，往后遍历就没有意义了，直接剪掉。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum &gt; n)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与77.组合一样，<code>for</code>循环也可以剪枝。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>; i++)</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">代码随想录 - 组合III</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 77.组合</title>
      <link href="/2022/07/25/LeetCode-77-%E7%BB%84%E5%90%88/"/>
      <url>/2022/07/25/LeetCode-77-%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="组合"><a class="markdownIt-Anchor" href="#组合"></a> 组合</h1><p><a href="https://leetcode.cn/problems/combinations/">LeetCode 77.组合</a></p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按<strong>任何顺序</strong>返回答案。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="方法一回溯"><a class="markdownIt-Anchor" href="#方法一回溯"></a> 方法一：回溯</h1><p><strong>算法思路：</strong></p><img src="/2022/07/25/LeetCode-77-%E7%BB%84%E5%90%88/20201123195242899.png" class="" title="77.组合1"><ol><li><p>确定递归函数的返回值以及参数</p><p>除了<code>n</code>与<code>k</code>，我们还需要设置变量<code>startIndex</code>，用来记录<strong>本层</strong>递归中，集合从哪里开始遍历。如，在取完<code>1</code>后，下一层递归就要在[2, 3, 4]中取数。</p></li><li><p>回溯函数的终止条件</p><p>当到达叶子节点时停止递归，即<code>path</code>数组的大小达到<code>k</code>。此时，用二维数组<code>result</code>将<code>path</code>保存起来，终止本层递归。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单层搜索的过程</p><p><code>for</code>循环用来横向遍历，递归的过程是纵向遍历。<code>for</code>循环每次从<code>startIndex</code>开始遍历，然后用<code>path</code>保存取到的节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n; i++)&#123;</span><br><span class="line">            path.add(i);<span class="comment">//将当前位置节点放入path中</span></span><br><span class="line">            backTracking(n, k, i + <span class="number">1</span>);<span class="comment">//递归：进入下一层遍历，注意搜索要从i+1开始</span></span><br><span class="line">            path.removeLast();<span class="comment">//回溯，撤销处理的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backTracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法二剪枝优化"><a class="markdownIt-Anchor" href="#方法二剪枝优化"></a> 方法二：剪枝优化</h1><p>如果在起始位置之后的元素个数全部加入到<code>path</code>中也达不到<code>k</code>，那就没必要搜索了。</p><ul><li><p>已经选择的元素个数：<code>path.size()</code></p></li><li><p>还需要的元素个数：<code>k - path.size()</code></p></li><li><p>在集合<code>n</code>中的最后起始位置：<code>n - (k - path.size()) + 1</code></p><p>例：n = 4, k = 3, 目前已选取0，<code>n - (k - path.size()) + 1 = 2</code>，最晚从2开始搜索，得[2,3,4]</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++)</span><br></pre></td></tr></table></figure><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://www.programmercarl.com/0077.%E7%BB%84%E5%90%88.html">代码随想录 - 组合</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 83.删除排序链表中的重复元素</title>
      <link href="/2022/07/09/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>/2022/07/09/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="删除排序链表中的重复元素"><a class="markdownIt-Anchor" href="#删除排序链表中的重复元素"></a> 删除排序链表中的重复元素</h1><p>给定一个已排序的链表的头 <code>head</code> ， 删除所有重复的元素，使每个元素只出现一次*。返回<strong>已排序</strong>的链表 。</p><img src="/2022/07/09/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/list2.jpg" class="" title="img"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><h1 id="方法一次遍历"><a class="markdownIt-Anchor" href="#方法一次遍历"></a> 方法：一次遍历</h1><p><strong>算法思路：</strong></p><p>若当前<code>cur</code>的值与<code>cur.next</code>相同，那么将<code>cur.next</code>删除，否则，<code>cur</code>指向<code>cur.next</code>。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是链表的长度。</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h1><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solution/shan-chu-pai-xu-lian-biao-zhong-de-zhong-49v5/">LeetCode题解-删除排序链表中的重复元素</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 67.二进制求和</title>
      <link href="/2022/07/05/LeetCode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/"/>
      <url>/2022/07/05/LeetCode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="二进制求和"><a class="markdownIt-Anchor" href="#二进制求和"></a> 二进制求和</h1><p><a href="https://leetcode.cn/problems/add-binary/">LeetCode 67.二进制求和</a></p><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">输出：&quot;100&quot;</span><br><span class="line"></span><br><span class="line">输入：a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出：“10101”</span><br></pre></td></tr></table></figure><h1 id="方法-模拟"><a class="markdownIt-Anchor" href="#方法-模拟"></a> 方法： 模拟</h1><p><strong>算法思路：</strong></p><ol><li>设置变量<code>carry</code>记录上一个位置的进位，初始值为0</li><li>使用<code>StringBuilder</code>拼接字符串，<code>a</code>、<code>b</code>从后往前遍历，最后将<code>StringBuilder</code>反转</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addBinary</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; a.charAt(i--) == <span class="string">&#x27;1&#x27;</span>)&#123;<span class="comment">//此处i--不能置于循环内，不然可能无法执行</span></span><br><span class="line">                carry++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; b.charAt(j--) == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                carry++;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(carry % <span class="number">2</span>);</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，这里的时间复杂度来源于顺序遍历 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>。</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，除去答案所占用的空间，这里使用了常数个临时变量。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://leetcode.cn/problems/add-binary/solution/er-jin-zhi-qiu-he-by-leetcode-solution/">LeetCode题解-二进制求和</a></p><p><a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.html#_1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95">LeetCode 题解 - 数学｜CS-Notes</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 680.验证回文串Ⅱ</title>
      <link href="/2022/07/03/LeetCode-680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%E2%85%A1/"/>
      <url>/2022/07/03/LeetCode-680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="验证回文串ii"><a class="markdownIt-Anchor" href="#验证回文串ii"></a> 验证回文串Ⅱ</h1><p><a href="https://leetcode.cn/problems/add-binary/">LeetCode 680.验证回文串Ⅱ</a></p><p>给你一个字符串 <code>s</code>，<strong>最多</strong>可以从中删除一个字符。</p><p>请你判断 <code>s</code> 是否能成为回文字符串：如果能，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aba&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s = &quot;abca&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：你可以删除字符 &#x27;c&#x27;。</span><br></pre></td></tr></table></figure><h1 id="方法递归"><a class="markdownIt-Anchor" href="#方法递归"></a> 方法：递归</h1><p><strong>算法思路：</strong></p><ol><li>构造判断是否为回文串方法<code>isPalindrome</code>，使用双指针法</li><li>对字符串进行双指针遍历，如果双指针所指的字符不同，则判断去除当前指针位置字符（左指针或右指针）的<strong>后续</strong>字符串是否为回文串</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = s.length() - <span class="number">1</span>; i &lt; j; i++, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s, i, j - <span class="number">1</span>) || isPalindrome(s, i + <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是字符串的长度。判断整个字符串是否是回文字符串的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，遇到不同字符时，判断两个子串是否是回文字符串的时间复杂度也都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。只需要维护有限的常量空间。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.html#_4-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2">LeetCode 题解 - 双指针｜CS-Notes</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 92.反转链表II</title>
      <link href="/2022/07/02/LeetCode-92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
      <url>/2022/07/02/LeetCode-92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表ii"><a class="markdownIt-Anchor" href="#反转链表ii"></a> 反转链表II</h1><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置<code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><img src="/2022/07/02/LeetCode-92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/rev2ex2.jpg" class="" title="img"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure><h1 id="方法分解后拼接"><a class="markdownIt-Anchor" href="#方法分解后拼接"></a> 方法：分解后拼接</h1><p><strong>算法思路：</strong></p><ol><li>设置哑节点<code>dummyNode</code>，记录开始位置。</li><li>设置<code>pre</code>节点，位移到需反转链表前一位，设置节点<code>leftNode = pre.next</code>后，执行<code>pre.next = null</code>断开链接。</li><li>设置<code>rightNode = pre</code>，位移至需反转链表末位，记录<code>cur = rightNode.next</code>，执行<code>rightNode.next = null</code>断开链接。</li><li>编写反转链表代码，反转<code>leftNode</code>。</li><li><code>pre.next = rightNode</code>与<code>leftNode.next = cur</code>链接三段链表。</li></ol><img src="/2022/07/02/LeetCode-92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/1615105168-ZQRZew-image.png" class="" title="image.png"><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//找到leftNode节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line"><span class="comment">//找到rightNode节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            rightNode = rightNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//断开链表</span></span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> rightNode.next;</span><br><span class="line">        rightNode.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        reverseListNode(leftNode);</span><br><span class="line"><span class="comment">//链接三段链表</span></span><br><span class="line">        pre.next = rightNode;</span><br><span class="line">        leftNode.next = cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseListNode</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析"></a> 复杂度分析：</h1><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是链表总节点数。最坏情况下，需要遍历整个链表。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。只使用到常数个变量。</li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">LeetCode官方题解 - 92.反转链表II</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 21.合并两个有序链表</title>
      <link href="/2022/07/02/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/07/02/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h1><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表 - 力扣（LeetCode）</a></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><img src="/2022/07/02/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/merge_ex1.jpg" class="" title="img"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><h1 id="方法一递归"><a class="markdownIt-Anchor" href="#方法一递归"></a> 方法一：递归</h1><p><strong>算法思路：</strong></p><p>比较两个链表的头部值，较小的一个节点与剩下元素的<code>merge</code>操作结果合并。</p><img src="/2022/07/02/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/44791a290462582675ea3377dbac43fada52391fb6545f6f9947d6e33feb928c-%E5%B9%BB%E7%81%AF%E7%89%872.jpeg" class="" title="img"><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">            list1.next = mergeTwoLists(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list2.next = mergeTwoLists(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>是链表的长度，至多只会递归调用两个链表的每个节点一次。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，同上。</li></ul><h1 id="方法二双指针"><a class="markdownIt-Anchor" href="#方法二双指针"></a> 方法二：双指针</h1><p><strong>算法思路：</strong></p><ol><li>设置一个哨兵节点<code>prehead</code>，以便最后返回合并后的链表。</li><li>维护<code>prev</code>指针，比较<code>l1</code>与<code>l2</code>的节点值，若<code>l1</code>小于<code>l2</code>，则将<code>l1</code>当前节点接在<code>prev</code>后面，同时将<code>l1</code>指针后移一位。对<code>l2</code>同理，如此循环直至<code>l1</code>或<code>l2</code>指向了<code>null</code>。</li><li>循环终止时，合并剩余的非空链表。</li></ol><img src="/2022/07/02/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/10.png" class="" title="img"><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prehead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> prehead;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">                prev.next = list1;</span><br><span class="line">                prev = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev.next = list2;</span><br><span class="line">                prev = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = list1 == <span class="literal">null</span>? list2: list1;</span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，。其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>是链表的长度，<code>while</code>循环的次数不会超过两个链表的长度之和。</p></li><li><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，只需要常数的空间存放若干变量。</p></li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h1><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">合并两个有序链表 - 合并两个有序链表 - 力扣（LeetCode）</a></p><h1 id="参考-2"><a class="markdownIt-Anchor" href="#参考-2"></a> 参考</h1>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 206.反转链表</title>
      <link href="/2022/07/01/LeetCode-206-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
      <url>/2022/07/01/LeetCode-206-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><img src="/2022/07/01/LeetCode-206-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/rev1ex1.jpg" class="" title="img"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><h1 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h1><img src="/2022/07/01/LeetCode-206-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png" class="" title="反转链表"><p><strong>算法思路：</strong></p><ol><li>将<code>next = cur.next</code>储存起来</li><li><code>cur.next = pre</code></li><li><code>pre</code>与<code>cur</code>向后移</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是链表的长度，需要遍历链表一次。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul><h1 id="方法二递归"><a class="markdownIt-Anchor" href="#方法二递归"></a> 方法二：递归</h1><p>假设链表为：</p><p><code>1→2→3→4→5</code></p><p>某一时刻，我们处于如下状态：</p><p><code>1→2→3←4←5</code></p><p>我们希望<code>3</code>的下一个节点指向<code>2</code>，所以<code>2.next.next = 2</code>。</p><p>需要注意的是，头结点的下一个节点必须指向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66334em;vertical-align:-0.08167em;"></span><span class="mord amsrm">∅</span></span></span></span>，不然可能会产生环。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是链表的长度。需要对链表的每个节点进行反转操作。</p></li><li><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 层。</p></li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/">反转链表 - 反转链表 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 160.相交链表</title>
      <link href="/2022/06/27/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/06/27/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="相交链表"><a class="markdownIt-Anchor" href="#相交链表"></a> 相交链表</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">LeetCode 160.相交链表</a></p><p>给你两个单链表的头节点<code>headA</code>和<code>headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回<code>null</code>。</p><p>图示两个链表在节点<code>C1</code>开始相交：</p><img src="/2022/06/27/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/160_statement.png" class="" title="img"><p>题目数据<strong>保证</strong>整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须<strong>保持其原始结构</strong>。</p><h1 id="方法1双指针"><a class="markdownIt-Anchor" href="#方法1双指针"></a> 方法1：双指针</h1><p><strong>算法思路：</strong></p><p>设A的长度为a + c，B的长度为b + c，其中c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p><p>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p><p>如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> headA, l2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">        l1 = (l1 == <span class="literal">null</span>) ? headB : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="literal">null</span>) ? headA : l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 是分别是链表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">headA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">headB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</p></li><li><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p></li></ul><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/comments/">160. 相交链表 - 力扣（LeetCode）</a></p><p><a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.html#_1-%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9">Leetcode 题解 - 链表 | CS-Notes</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希集合 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring5学习之路（1） IOC容器</title>
      <link href="/2022/06/15/Spring5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89-IOC%E5%AE%B9%E5%99%A8/"/>
      <url>/2022/06/15/Spring5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89-IOC%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ioc概念和原理"><a class="markdownIt-Anchor" href="#ioc概念和原理"></a> IOC概念和原理</h1><ol><li><p>概念：控制反转，把对象创建和对象的调用过程交给Spring进行管理。</p><p>目的：<strong>降低耦合度</strong></p><p>底层原理：<strong>xml，反射，工厂模式</strong></p><p>为何要做这样一种操作，可以参考普通创建对象方式与工厂模式的区别。</p><img src="/2022/06/15/Spring5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89-IOC%E5%AE%B9%E5%99%A8/image-20220615175511052.png" class="" title="原始方式"><p>原始的创建对象的方式耦合度太高，当UserDao发生变化时，UserService也要跟着进行修改。为实现高内聚、低耦合的目标，可以使用<strong>工厂模式</strong>。 <img src="/2022/06/15/Spring5%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89-IOC%E5%AE%B9%E5%99%A8/image-20220619105625180.png" class="" title="工厂模式"></p><p>若要进一步降低耦合度，可以使用IOC进行解耦。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：xml配置文件，配置创建的对象</span></span><br><span class="line">&lt;<span class="type">bean</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;dao&quot;</span> class = <span class="string">&quot;com.atguigu.UserDao&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//第二步：有service类和dao类，创建工厂类（该步骤由spring执行）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserFactory</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">getDao</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">classValue</span> <span class="operator">=</span> class属性值; <span class="comment">//1、xml解析，此处class属性值为com.atguigu.UserDao</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(classValue); <span class="comment">//2、通过反射创建对象,forName(类的全路径)</span></span><br><span class="line">    <span class="keyword">return</span> (UserDao)clazz.newInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring提供IOC容器两种实现方式：（两个接口）</p><ol><li><p><strong>BeanFactory</strong>：Spring内部使用的接口，不提倡开发人员使用。</p><p><strong>特点</strong>：加载配置文件的时不会创建对象，获取对象时才会创建对象。</p></li><li><p><strong>ApplicationContext</strong>：BeanFactory的子接口，提供了更多更强大的功能，一般由开发人员使用。</p><p><strong>特点</strong>：加载配置文件时会把配置文件里的对象进行创建。比如当服务器启动时，便将对象创建，以供后续使用，空间换时间。</p><p>ApplicationContext接口的两个实现类：</p><ul><li>FileSystemXmlApplicationContext：绝对路径，从盘符开始算起</li><li>ClassPathXmlApplicationContext：相对路径，从src开始算起</li></ul></li></ol><h1 id="ioc操作bean管理概念"><a class="markdownIt-Anchor" href="#ioc操作bean管理概念"></a> IOC操作Bean管理（概念）</h1><ol><li><p>什么是Bean管理</p><p>Bean管理指的是两个操作：<strong>Spring创建对象</strong>和<strong>Spring注入属性</strong></p></li><li><p>Bean管理有两种操作方式：</p><ul><li>基于xml配置文件方式实现</li><li>基于注解方式实现</li></ul></li></ol><h1 id="ioc操作bean管理基于xml方式"><a class="markdownIt-Anchor" href="#ioc操作bean管理基于xml方式"></a> IOC操作Bean管理（基于xml方式）</h1><ol><li><p>基于xml方式创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--配置User对象创建--&gt;</span><br><span class="line">&lt;<span class="type">bean</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span> class = <span class="string">&quot;com.atguigu.spring5.User&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ul><li>在Spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建</li><li>在bean标签有很多属性，常用属性：<ul><li>id：唯一标识</li><li>class属性：类全路径（包类路径）</li></ul></li><li>创建对象的时候，默认执行<strong>无参数构造方法</strong>完成对象创建</li></ul></li><li><p>基于xml方式注入属性</p><p><strong>第一种方法</strong>：使用set方法进行注入</p><p>（1）创建类，定义属性和对应的set方法</p><p><strong>第二种方法</strong>：使用有参构造函数进行注入</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java技术栈 </category>
          
          <category> Spring5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 104.二叉树的最大深度</title>
      <link href="/2022/06/06/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2022/06/06/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的最大深度"><a class="markdownIt-Anchor" href="#二叉树的最大深度"></a> 二叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LeetCode 104.二叉树的最大深度</a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong></p><img src="/2022/06/06/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/tmp-tree.jpg" class=""><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h2 id="方法1递归深度优先搜索"><a class="markdownIt-Anchor" href="#方法1递归深度优先搜索"></a> 方法1：递归/深度优先搜索</h2><p><strong>算法思路：</strong></p><ul><li><p>如果已知左子树和右子树的最大深度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，则二叉树的最大深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">max(l,r) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p></li><li><p>左子树和右子树的最大深度又可以以同样的方式进行计算</p></li><li><p>递归的终止条件：访问到空节点</p></li></ul><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为二叉树节点的个数。每个节点在递归中只被遍历一次。</p></li><li><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(height)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(height)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p></li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/">力扣官方题解：二叉树的最大深度</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客部署时提示use a personal access token instead的解决方法</title>
      <link href="/2022/05/04/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%97%B6%E6%8F%90%E7%A4%BAuse-a-personal-access-token-instead%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2022/05/04/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%97%B6%E6%8F%90%E7%A4%BAuse-a-personal-access-token-instead%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p>在跟随up主<a href="https://www.bilibili.com/video/BV1Yb411a7ty?p=1&amp;share_medium=android&amp;share_plat=android&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1635071237&amp;unique_k=kYdWS1">codesheep</a>搭建hexo博客时，在进行到使用hexo d命令部署到github仓库时，输入完账号密码后会弹出如下的错误信息，这是因为github不允许使用账号密码连接了，需要创建自己的token。</p><blockquote><p>Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</p></blockquote><h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1><ol><li><p>生成新SSH</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;yourmail@example.com&quot;</span><br></pre></td></tr></table></figure><p>&quot;<a href="mailto:yourmail@example.com">yourmail@example.com</a>&quot;中填写注册github所用的邮箱。然后会提示生成路径，记住路径并一路回车（也可以自己输入路径），在相应的路径会生成<code>.ssh</code>和<code>.ssh.pub</code>文件，如果并没有找到的话，可点击<code>Command + Shift +.(句号)</code>来显示隐藏文件。</p><img src="/2022/05/04/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%97%B6%E6%8F%90%E7%A4%BAuse-a-personal-access-token-instead%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/1.jpg" class="" title="生成ssh图"></li><li><p>绑定SSH</p><p>登陆<code>Github</code>，依次点击<code>右上角头像框</code>-&gt;<code>Settings</code>-&gt; <code>SSH and GPG keys</code>-&gt;<code>New SSH key</code>，在其中输入相应的信息。</p></li></ol><img src="/2022/05/04/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%97%B6%E6%8F%90%E7%A4%BAuse-a-personal-access-token-instead%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/2.png" class="" title="github的ssh图"><ol start="3"><li><p>生成自己的token</p><p>在<code>Settings</code>侧边栏依次点击<code>Developer settings</code>-&gt;<code>Personal access tokens</code>-&gt;<code>Generate new token</code>。在设置好名称、有效期与权限后，点击<code>Generate token</code>生成token。复制好生成的token，若关闭界面就再也看不到此token了。</p></li></ol><img src="/2022/05/04/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%97%B6%E6%8F%90%E7%A4%BAuse-a-personal-access-token-instead%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/3.png" class="" title="token图"><ol start="4"><li><p>配置config</p><p>打开<code>blog</code>文件夹中的<code>_config.yml</code>文件，找到<code>deploy</code>一栏，将<code>repo</code>改写成<code>https://你的token@github.com/xxxxx</code>的格式即可。</p><img src="/2022/05/04/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%97%B6%E6%8F%90%E7%A4%BAuse-a-personal-access-token-instead%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/4.jpg" class="" title="deploy配置图"></li></ol><h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h1><p><a href="https://blog.csdn.net/qq934235475/article/details/119794518">https://blog.csdn.net/qq934235475/article/details/119794518</a></p><p><a href="https://www.jianshu.com/p/6e86c80c457c">https://www.jianshu.com/p/6e86c80c457c</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法复杂度</title>
      <link href="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>算法复杂度旨在描述 输入数据量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 时，算法的 <strong>时间使用</strong> 和 <strong>空间使用</strong> 情况</p><ul><li><p><strong>时间</strong>：假设各操作的运行时间为固定常数，统计算法运行的 <strong>计算操作的数量</strong> ，以代表算法运行所需时间</p></li><li><p><strong>空间</strong>：统计在<strong>最差情况下</strong> ，算法运行所需使用的 <strong>最大空间</strong></p></li></ul><p>输入数据大小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 指算法处理的输入数据量，根据不同算法，具有不同的定义，例如：</p><ul><li><strong>排序算法</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 代表需要排序的元素数量</li><li><strong>搜索算法</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 代表搜索范围的元素总数，例如数组大小、矩阵大小、二叉树节点数、图节点和边数等</li></ul><h1 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h1><p>统计的是算法的 <strong>计算操作数量</strong> ，而不是 运行的绝对时间</p><blockquote><p>计算操作数量 和 运行绝对时间 呈正相关关系，并不相等。算法运行时间受到「编程语言 、计算机处理器速度、运行环境」等多种因素影响。</p></blockquote><p>体现的是计算操作随数据大小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 变化时的变化情况。假设算法运行总共需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次操作、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次操作，此两情况的时间复杂度都为常数级 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>；需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 次操作、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mi>N</mi></mrow><annotation encoding="application/x-tex">100N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 次操作 的时间复杂度都为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><h2 id="符号表示"><a class="markdownIt-Anchor" href="#符号表示"></a> 符号表示</h2><p>时间复杂度具有 <strong>最差</strong>、<strong>平均</strong>、<strong>最佳</strong> 三种情况，分别使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span> 三种符号表示</p><p>题目：输入长度为 <code>N</code> 的整数数组 <code>nums</code>，判断此数组中是否有数字 <code>7</code>，若有则返回 <code>true</code>，否则返回 <code>false</code></p><p>解题算法： 线性查找，即遍历整个数组，遇到 <code>7</code> 则返回 <code>true</code></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findSeven</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最佳情况</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>：当数组首个数字为 <code>7</code> 时，无论 <code>nums</code> 有多少元素，线性查找的循环次数都为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次</p><p><strong>最差情况</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>：<code>nums</code> 中所有数字都不为 <code>7</code>，此时线性查找会遍历整个数组，循环 <code>N</code> 次</p><p><strong>平均情况</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span>：需要考虑输入数据的分布情况，计算所有数据情况下的平均时间复杂度。例如本题，需要考虑数组长度、数组元素的取值范围等</p><h2 id="常见种类"><a class="markdownIt-Anchor" href="#常见种类"></a> 常见种类</h2><p>根据从小到大排列，常见的算法时间复杂度主要有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1) &lt; O(\log N) &lt; O(N) &lt; O(N \log N) &lt; O(N^2) &lt; O(2^N) &lt; O(N!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></span></p><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/1.png" class="" title="算法时间复杂度常见种类"><h2 id="示例解析"><a class="markdownIt-Anchor" href="#示例解析"></a> 示例解析</h2><p>对于以下所有示例，设输入数据大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ，计算操作数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">count</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 。图中每个「蓝色方块」代表一个单元计算操作。</p><h3 id="常数-o1"><a class="markdownIt-Anchor" href="#常数-o1"></a> 常数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h3><p>运行次数与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 大小呈常数关系，即不随输入数据大小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 的变化而变化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> x = a * b + N;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以下代码，无论 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 取多大，都与输入数据大小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 无关，因此时间复杂度仍为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/2.png" class="" title="$O(1)$ 时间复杂度"><h3 id="线性-on"><a class="markdownIt-Anchor" href="#线性-on"></a> 线性 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h3><p>循环运行次数与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 大小呈线性关系，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前一个例子的循环次数并不随 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 改变，而这里的循环次数会随 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 变化</p><p>对于以下代码，虽然是两层循环，但第二层与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 大小无关，因此整体仍与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 呈线性关系</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; a; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/3.png" class="" title="$O(N)$ 时间复杂度"><h3 id="平方-on2"><a class="markdownIt-Anchor" href="#平方-on2"></a> 平方 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3><p>两层循环相互独立，都与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 呈线性关系，因此总体与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 呈平方关系</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <strong>冒泡排序</strong> 为例，其包含两层独立循环：</p><ul><li>第一层复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ；</li><li>第二层平均循环次数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，推导过程如下：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\frac{N}{2}) = O(\frac{1}{2})O(N) = O(1)O(N) = O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p><p>因此，冒泡排序的总体时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，代码如下所示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> N = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/4.png" class="" title="$O(N^2)$ 时间复杂度"><h3 id="指数-o2n"><a class="markdownIt-Anchor" href="#指数-o2n"></a> 指数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3><p>生物学科中的 “细胞分裂” 即是指数级增长</p><p>算法中，指数阶常出现于 <strong>递归</strong> ，算法原理图与代码如下所示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count_1 = <span class="built_in">algorithm</span>(N - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> count_2 = <span class="built_in">algorithm</span>(N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> count_1 + count_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/5.png" class="" title="$O(2^N)$ 时间复杂度"><h3 id="阶乘-on"><a class="markdownIt-Anchor" href="#阶乘-on"></a> 阶乘 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></h3><p>阶乘阶对应数学上常见的 “全排列”</p><p>如下图与代码所示，阶乘常使用 <strong>递归</strong> 实现，算法原理：第一层分裂出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个，第二层分裂出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个，…… ，直至到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 层时终止并回溯</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        count += <span class="built_in">algorithm</span>(N - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/6.png" class="" title="$O(N!)$ 时间复杂度"><h3 id="对数-olog-n"><a class="markdownIt-Anchor" href="#对数-olog-n"></a> 对数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h3><p>对数阶与指数阶相反，指数阶为 “每轮分裂出两倍的情况” ，而对数阶是 “每轮排除一半的情况” 。对数阶常出现于 <strong>二分法</strong> 、<strong>分治</strong> 等算法中，体现着 “一分为二” 或 “一分为多” 的算法思想</p><p>设循环次数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> ，则输入数据大小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">2^m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span></span></span> 呈线性关系，两边同时取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span> 对数，则得到循环次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2 N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 呈线性关系，即时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> i = N;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        i = i / <span class="number">2</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如以下代码所示，对于不同 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的取值，循环次数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>a</mi></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_a N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.057252em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 呈线性关系，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>a</mi></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_a N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.057252em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。无论底数 a 取值，时间复杂度都可以记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>a</mi></msub><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>a</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_a N) = \frac{O(\log_2 N)}{O(\log_2 a)} = O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.057252em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> i = N;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        i = i / a;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，为二分查找的时间复杂度示意图，每次二分将搜索区间缩小一半，二分的次数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2 N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></p><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/7.png" class="" title="$O(\log N)$ 时间复杂度"><h3 id="线性对数-on-log-n"><a class="markdownIt-Anchor" href="#线性对数-on-log-n"></a> 线性对数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h3><p>两层循环相互独立，第一层和第二层时间复杂度分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，则总体时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> i = N;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        i = i / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性对数阶常出现于排序算法，例如 <strong>快速排序</strong> 、<strong>归并排序</strong> 、<strong>堆排序</strong> 等，其时间复杂度原理如下图所示</p><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/8.png" class="" title="$O(N \log N)$ 时间复杂度"><p><a href="https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/On%E7%9A%84%E7%AE%97%E6%B3%95%E5%B1%85%E7%84%B6%E8%B6%85%E6%97%B6%E4%BA%86%EF%BC%8C%E6%AD%A4%E6%97%B6%E7%9A%84n%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A4%9A%E5%A4%A7%EF%BC%9F.html#%E5%81%9A%E4%B8%AA%E6%B5%8B%E8%AF%95%E5%AE%9E%E9%AA%8C">代码随想录：估计计算机在 1s 内能执行多少次操作：</a><br /><img src="%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%5Ctest.png" alt="" /></p><p><a href="https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html">代码随想录：递归算法的时间复杂度分析</a></p><h1 id="空间复杂度"><a class="markdownIt-Anchor" href="#空间复杂度"></a> 空间复杂度</h1><p>空间复杂度涉及的空间类型有：</p><ul><li><p><strong>输入空间</strong> ： 存储输入数据所需的空间大小</p></li><li><p><strong>暂存空间</strong> ： 算法运行过程中，存储所有中间变量和对象等数据所需的空间大小</p></li><li><p><strong>输出空间</strong> ： 算法运行返回时，存储输出数据所需的空间大小</p></li></ul><p>通常情况下，空间复杂度指在输入数据大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 时，算法运行所使用的 <strong>暂存空间 + 输出空间</strong> 的总体大小</p><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/9.png" class="" title="空间类型"><p>根据不同来源，算法使用的内存空间分为三类：</p><ol><li><p><strong>指令空间</strong> ：编译后，程序指令所使用的内存空间</p></li><li><p><strong>数据空间</strong> ：算法中的各项变量使用的空间，包括：声明的常量、变量、动态数组、动态对象等使用的内存空间</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node *next;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = N;              <span class="comment">// 变量</span></span><br><span class="line">        <span class="type">int</span> nums[N];              <span class="comment">// 动态数组</span></span><br><span class="line">        Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(N); <span class="comment">// 动态对象</span></span><br><span class="line">    &#125;```</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> **栈帧空间** ：程序 **调用函数** 是基于 **栈** 实现的，函数在调用期间，占用常量大小的栈帧空间，直至返回后释放。如以下代码所示，在循环中调用函数，每轮调用 `<span class="built_in">test</span>()` 返回后，栈帧空间已被释放，因此空间复杂度仍为 $<span class="built_in">O</span>(<span class="number">1</span>)$</span><br><span class="line"></span><br><span class="line">    ```<span class="function">cpp</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="built_in">test</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>算法中，<strong>栈帧空间的累计常出现于递归调用</strong> 。如以下代码所示，通过递归调用，会同时存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个未返回的函数 <code>algorithm()</code> ，此时累计使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 大小的栈帧空间</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">algorithm</span>(N - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="符号表示-2"><a class="markdownIt-Anchor" href="#符号表示-2"></a> 符号表示</h2><p>通常情况下，空间复杂度统计 <strong>算法在 “最差情况” 下使用的空间大小</strong> ，以体现算法运行所需预留的空间量，使用符号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span> 表示</p><p>最差情况有两层含义，分别为 <strong>最差输入数据</strong> 、算法运行中的 <strong>最差运行点</strong></p><p>例如以下代码：输入整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ，取值范围 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;           <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        nums.<span class="built_in">resize</span>(N);    <span class="comment">// O(N)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>最差输入数据</strong> ： 当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">N \le 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 时，数组 <code>nums</code> 的长度恒定为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> ，空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mi>O</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(10) = O(1) O(10) = O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>&gt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">N &gt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 时，数组 <code>nums</code> 长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ，空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。因此，空间复杂度应为最差输入数据情况下的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li><strong>最差运行点</strong> ： 在执行 <code>nums(10)</code> 时，算法仅使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 大小的空间；而当执行 <code>nums.resize(N)</code> 时，算法使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的空间；因此，空间复杂度应为最差运行点的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="常见种类-2"><a class="markdownIt-Anchor" href="#常见种类-2"></a> 常见种类</h2><p>根据从小到大排列，常见的算法空间复杂度有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1) &lt; O(\log N) &lt; O(N) &lt; O(N^2) &lt; O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/10.png" class="" title="算法空间复杂度常见种类"><h2 id="示例解析-2"><a class="markdownIt-Anchor" href="#示例解析-2"></a> 示例解析</h2><p>对于以下所有示例，设输入数据大小为正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ，节点类 <code>Node</code> 、函数 <code>test()</code> 如以下代码所示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点类 Node</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 test()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常数-o1-2"><a class="markdownIt-Anchor" href="#常数-o1-2"></a> 常数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h3><p>普通常量、变量、对象、元素数量与输入数据大小 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 无关的集合，皆使用常数大小的空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">10000</span>];</span><br><span class="line">    Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, string&gt; dic;</span><br><span class="line">    dic.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如以下代码所示，虽然函数 <code>test()</code> 调用了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 次，但每轮调用后 <code>test()</code> 已返回，无累计栈帧空间使用，因此空间复杂度仍为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性-on-2"><a class="markdownIt-Anchor" href="#线性-on-2"></a> 线性 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h3><p>元素数量与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 呈线性关系的任意类型集合（常见于 <strong>一维数组</strong> 、<strong>链表</strong> 、<strong>哈希表</strong> 等），皆使用线性大小的空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> nums_1[N];</span><br><span class="line">    <span class="type">int</span> nums_2[N / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    vector&lt;Node*&gt; nodes;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        nodes.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, string&gt; dic;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        dic.<span class="built_in">emplace</span>(i, <span class="built_in">to_string</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图与代码所示，此递归调用期间，会同时存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个未返回的 <code>algorithm()</code> 函数，因此使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 大小的栈帧空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">algorithm</span>(N - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/11.png" class="" title="$O(N)$ 空间复杂度"><h3 id="平方-on2-2"><a class="markdownIt-Anchor" href="#平方-on2-2"></a> 平方 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3><p>元素数量与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 呈平方关系的任意类型集合（常见于矩阵），皆使用平方大小的空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; num_matrix;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num_matrix.<span class="built_in">push_back</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;Node*&gt;&gt; node_matrix;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        vector&lt;Node*&gt; nodes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            nodes.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(j));</span><br><span class="line">        &#125;</span><br><span class="line">        node_matrix.<span class="built_in">push_back</span>(nodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图与代码所示，递归调用时同时存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个未返回的 <code>algorithm()</code> 函数，使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 栈帧空间；每层递归函数中声明了数组，平均长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> ，使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 空间；因此总体空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nums[N];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">algorithm</span>(N - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/12.png" class="" title="$O(N^2)$ 空间复杂度"><h3 id="指数-o2n-2"><a class="markdownIt-Anchor" href="#指数-o2n-2"></a> 指数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h3><p>指数阶常见于 <strong>二叉树</strong> 、<strong>多叉树</strong></p><p>例如，高度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 的 满二叉树（perfect binary tree） 的节点数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span> ，占用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 大小的空间；同理，高度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 的 满 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 叉树 的节点数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>m</mi><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">m^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span> ，占用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mi>N</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>N</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m^N) = O(2^N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 大小的空间</p><img src="/2022/03/25/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/13.png" class="" title="$O(2^N)$ 空间复杂度"><h3 id="对数-olog-n-2"><a class="markdownIt-Anchor" href="#对数-olog-n-2"></a> 对数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></h3><p>对数阶常出现于分治算法的栈帧空间累计、数据类型转换等，例如：</p><ul><li><strong>快速排序</strong> ，平均空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> ，最差空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。拓展知识：通过应用 <a href="https://stackoverflow.com/questions/310974/what-is-tail-call-optimization">Tail Call Optimization</a> ，可以将快速排序的最差空间复杂度限定至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li><strong>数字转化为字符串</strong> ，设某正整数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ，则字符串的空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 。推导如下：正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 的位数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>10</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_{10} N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ，即转化的字符串长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>10</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_{10} N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> ，因此空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li></ul><p><a href="https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.html#%E9%80%92%E5%BD%92%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">代码随想录：递归算法的性能分析</a></p><h1 id="时空权衡"><a class="markdownIt-Anchor" href="#时空权衡"></a> 时空权衡</h1><p>优良的算法应具备两个特性，即时间和空间复杂度皆较低</p><p>实际上，对于某个算法问题，同时优化时间复杂度和空间复杂度是非常困难的。降低时间复杂度，往往是以提升空间复杂度为代价的，反之亦然</p><blockquote><p>由于当代计算机的内存充足，<em>通常情况下</em>，算法设计中一般会采取「空间换时间」的做法，即 <strong>牺牲部分计算机存储空间，来提升算法的运行速度</strong></p></blockquote><p>以 <a href="https://leetcode-cn.com/problems/two-sum/">LeetCode 1. 两数之和</a> 为例，暴力枚举 和 辅助哈希表 分别为 空间最优 和 时间最优 的两种算法</p><p>注：以上内容来自于 <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r8ytog/">https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/r8ytog/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
